import json, os, subprocess, glob, sys, shutil, bs4, random, hashlib, string
sys.path.append(".")
import form_generator, generate_table, generate_tables, generate_detail, generate_common, generate_graph, custom, custom_prompt_types
## CONSTANTS
appdesigner = ".."
tmp = "/tmp"

def do_command(push, command, quiet):
	if type(command) != type([]):
		raise Exception("Unsafe subprocess command")
	if push:
		out = sys.stdout
		if quiet:
			out = open(os.devnull, "w")
		else:
			print(" ".join(command))
		subprocess.check_call(command, stdout = out)
def message(msg):
	err = "## " + msg + " ##"
	print("#" * len(err))
	print(err)
	print("#" * len(err))
def check_syntax(file, quiet):
	if file.split(".")[-1].upper() == "JS":
		if not quiet: print("Checking file " + file + " for syntax errors")
		try:
			subprocess.check_call(["acorn", "--silent", file]);
		except:
			if not quiet: message("Syntax error")
			raise Exception("Syntax error")
	elif file.split(".")[-1].upper() == "HTML":
		try:
			soup = bs4.BeautifulSoup(open(file, "r").read(), "html.parser")
			scripts = soup.find_all("script")
			total = len(scripts);
			i = 0;
			for script in scripts:
				i += 1;
				text = script.text;
				length = len(text.strip())
				if not quiet: print("Checking script tag " + str(i) + " of " + str(total) + " in file " + file + " - " + str(length) + " bytes")
				if length == 0: continue
				#r, w = os.pipe();
				#os.write(w, text.encode("utf-8"));
				#os.close(w)
				#subprocess.check_call(["acorn", "--silent"], stdin = r);
				tempfile = tmp + "/script_" + gensym();
				open(tempfile, "wb").write(text.encode("utf-8"))
				subprocess.check_call(["acorn", "--silent", tempfile])
				os.remove(tempfile)
		except:
			if not quiet: message("Syntax error")
			raise Exception("Syntax error")

# like S4 in formgen_common.js, just makes four random 0-9a-f digits, used in gensym
def genpart(): return hex(random.randint(0, 2**(8*2))).split("x")[1].rjust(4, "0")
# returns a random guid, used for translation tokens
def gensym(thing = False):
	if thing:
		return hashlib.md5(str(thing).encode("utf-8")).hexdigest()
	return genpart() + genpart() + "-4" + genpart()[1:] + "-" + genpart() + "-" + genpart() + genpart() + genpart()
def userjs(thing):
	result = "";
	for c in thing:
		if c in string.ascii_letters + "0123456789_-":
			result += c
		else:
			result += "_"
	return result
class utils():
	# Added to the top of every html file, a simple warning followed by some blank lines so the reader notices it
	warning = "<!--\nThis file is automatically generated and all changes will be overwritten" + "".join("\n" for i in range(15)) + "-->"
	def __init__(self):
		self.appdesigner = appdesigner
		self.filenames = []
		self.custom_prompt_types = [];
	@staticmethod
	def gensym(thing = False): return gensym(thing)
	@staticmethod
	def userjs(thing): return userjs(thing)
	# Tries to pull the main display column from the formDef, almost always doesn't work
	def yank_instance_col(self, table): return self.yank_setting(table, table, "instance_name", "_id");
	# Tries to pull the requested setting from the formDef, or return the default argument if it can't find it
	def yank_setting(self, table, form, setting, default):
		formDef = json.loads(open(appdesigner + "/app/config/tables/" + table + "/forms/" + form + "/formDef.json", "r").read())
		try:
			return [x for x in formDef["xlsx"]["settings"] if x["setting_name"] == setting][0]["value"]
		except:
			pass
		try:
			return [x for x in formDef["xlsx"]["settings"] if x["setting_name"] == setting][0]["display"]
		except:
			pass
		try:
			return formDef["xlsx"]["specification"]["settings"][setting]["value"]
		except:
			pass
		try:
			return formDef["xlsx"]["specification"]["settings"][setting]["display"]
		except:
			return default;
	# Returns a map of {(:table_id): localized_table_name} for each table. If no localized display name was found, uses the table id
	def get_localized_tables(self):
		result = {}
		for table in self.get_tables():
			# Try and pull the display name from the settings in the formDef
			result[table] = self.yank_setting(table, table, "survey", table)
		return result
	# Returns a list of all the tables that formgen was able to successfully generate html files for
	def get_allowed_tables(self):
		return [x.split("/")[1] for x in self.filenames if len(x.split("/")) > 2 and x.split("/")[2] == "index.html" and x.split("/")[0] == "formgen"]
	# Returns a list of every table in app designer
	def get_tables(self):
		return [os.path.basename(x) for x in glob.glob(appdesigner + "/app/config/tables/*")]
	def get_forms(self, table):
		return [os.path.basename(x) for x in glob.glob(appdesigner + "/app/config/tables/" + table + "/forms/*")]
	def register_custom_prompt_type(self, type, css_class, html_factory, js):
		self.custom_prompt_types.append([type, css_class, html_factory, js]);
	def make(self, appname, push, do_syntax_check = True, quiet = False):
		if appname == "fail":
			raise Exception("No branch or appname given")
		try:
			subprocess.check_call(["command", "-v", "acorn"], stdout=open(os.devnull, "w"))
		except:
			message("Acorn is not installed -- Not running syntax checks")
			message("TESTS WILL FAIL")
			do_syntax_check = False
		self.queue = []
		self.appname = appname
		if self.appdesigner[-1] == "/": self.appdesigner = self.appdesigner[:-1]
		ad_subpath = self.appdesigner + "/app/config/assets"
		static_files = ["formgen_common.js", "form_generator.js", "form_generator.css", "generate_common.js", "generate_detail.css", "generate_detail.js", "generate_index.css", "generate_index.js", "generate_table.css", "generate_table.js", "graph.js", "graph.css", "tabs.css", "tabs.js", "map.js", "generate_table_list.js", "generate_table_group_by.js", "generate_table_collection.js", "generate_table_static.js"]

		custom_prompt_types.make(self);

		self.filenames, choices, which = form_generator.generate_all(self, self.filenames, quiet)

		if not os.path.exists("userjs"):
			if not quiet: print("mkdir userjs")
			os.mkdir("userjs")

		self.filenames.append("table.html")
		generate_table.make(self, "table.html", "", "", "", "", "")
		self.filenames.append("table_slave.html")
		appname_save = self.appname
		self.appname = "app"
		generate_table.make(self, "table_slave.html", "", "", "embedded = true;", "", "")
		self.appname = appname_save

		self.filenames.append("tables.html")
		generate_tables.make(self, "tables.html");

		self.filenames.append("detail.html")
		generate_detail.make(self, "detail.html", "", "", "", "")

		self.filenames.append("graph.html")
		generate_graph.make(self, "graph.html", "", "");
		self.filenames.append("formgen/graph_iframe.html")
		generate_graph.make(self, "formgen/graph_iframe.html", "", "window.iframeOnly = true;");

		self.filenames, user_translations, new_static_files = custom.make(appname, self, self.filenames)
		static_files += new_static_files;

		self.filenames.append("formgen_common.js")
		generate_common.make(self, "formgen_common.js", user_translations, choices, which)

		try:
			if quiet:
				try:
					import pip._vendor.progress.bar as libbar
				except:
					import fakebar as libbar
				bar = libbar.IncrementalBar(max = len(self.queue + self.filenames + static_files))
				bar.start()
			bar_idx = 0;
			for q in self.queue:
				command = q
				do_command(push, command, quiet)
				if quiet:
					bar_idx += 1;
					bar.index = bar_idx
					bar.update();
			for f in self.filenames + static_files:
				if do_syntax_check: check_syntax(f, quiet)
				command = ["adb", "shell", "mkdir", "-p", "/sdcard/opendatakit/" + appname + "/config/assets/" + "/".join(f.split("/")[:-1])]
				do_command(push, command, quiet)
				command = ["adb", "push", f, "/sdcard/opendatakit/" + appname + "/config/assets/" + f]
				do_command(push, command, quiet)
				dest = ad_subpath + "/" + "/".join(f.split("/")[:-1])
				if dest in ["table_slave.html"]: continue
				if not quiet: print("mkdir -p " + dest);
				try:
					os.makedirs(dest)
				except FileExistsError:
					pass
				dest = ad_subpath + "/" + f
				if not quiet: print("cp " + f + " " + dest)
				shutil.copyfile(f, dest);
				if quiet:
					bar_idx += 1;
					bar.index = bar_idx
					bar.update();
			if quiet:
				bar.finish();
		finally:
			dirs = set()
			for f in self.filenames:
				if f[0] == "/" or f[:2] == "..": continue # RELATIVE PATHS ONLY, DON'T WANT TO END UP REMOVING /home OR /Users OR SOMETHING BAD
				if len(f.split("/")) > 1:
					dirs.add(f.split("/")[0])
				if not quiet: print("rm " + f)
				os.remove(f)
			for f in dirs:
				if not quiet: print("rm -rf " + f)
				shutil.rmtree(f);

def make(appname, push, do_syntax_check = True, quiet = False): utils().make(appname, push, do_syntax_check, quiet)
